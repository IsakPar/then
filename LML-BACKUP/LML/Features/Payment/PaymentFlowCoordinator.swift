//
//  PaymentFlowCoordinator.swift
//  Last Minute Live
//
//  Coordinates payment flows with Stripe WebKit and Apple Pay
//  Implements local-first ticket storage and enterprise-grade error handling
//

import Foundation
import PassKit
import WebKit
import Combine
import SwiftUI
import Stripe

// MARK: - Protocol Definitions

protocol PaymentOfflineDataManagerProtocol {
    func getCachedUserBookings() async throws -> [LocalUserBooking]?
    func cacheUserBookings(_ bookings: [LocalUserBooking]) async throws
}

// MARK: - Mock API Client Implementation

class PaymentMockAPIClient: APIClientProtocol {
    static let shared = PaymentMockAPIClient()
    
    private init() {}
    
    func createPaymentIntent(for booking: BookingRequest, applePayMethod: PKPaymentMethod? = nil) async throws -> PaymentIntentResponse {
        // Simulate network delay
        try await Task.sleep(nanoseconds: UInt64.random(in: 500_000_000...1_500_000_000))
        
        // Simulate occasional network errors (5% chance)
        if Int.random(in: 1...20) == 1 {
            throw PaymentError.networkError
        }
        
        // Validate booking amount
        guard booking.totalAmount > 0 else {
            throw PaymentError.invalidPaymentMethod
        }
        
        let paymentMethodType = applePayMethod != nil ? "applepay" : "card"
        
        return PaymentIntentResponse(
            clientSecret: "pi_\(UUID().uuidString.prefix(8))_secret_\(paymentMethodType)",
            amount: booking.totalAmount,
            currency: "gbp"
        )
    }
    
    func confirmBooking(paymentIntentId: String, booking: BookingRequest) async throws -> LocalBookingConfirmation {
        // Simulate backend processing time
        try await Task.sleep(nanoseconds: UInt64.random(in: 1_000_000_000...3_000_000_000))
        
        // Simulate occasional booking failures (3% chance)
        if Int.random(in: 1...35) == 1 {
            throw PaymentError.bookingCreationFailed
        }
        
        let bookingId = "LML\(Date().timeIntervalSince1970.description.replacingOccurrences(of: ".", with: ""))"
        
        return LocalBookingConfirmation(
            bookingId: bookingId,
            showId: booking.showId,
            showTitle: booking.showTitle,
            showDate: booking.showDate,
            showTime: booking.showTime,
            venueName: booking.venueName,
            venueAddress: booking.venueAddress,
            seats: booking.selectedSeats,
            totalAmount: booking.totalAmount,
            paymentIntentId: paymentIntentId,
            qrCode: "", // Will be generated by coordinator
            bookingDate: Date(),
            status: .confirmed
        )
    }
    
    // Provide stub implementations for other required APIClientProtocol methods
    func signIn(credentials: SignInRequest) async throws -> AuthResponse {
        throw PaymentError.networkError
    }
    
    func signUp(request: SignUpRequest) async throws -> AuthResponse {
        throw PaymentError.networkError
    }
    
    func socialAuth(request: SocialAuthRequest) async throws -> AuthResponse {
        throw PaymentError.networkError
    }
    
    func verifyToken() async throws -> TokenVerificationResponse {
        throw PaymentError.networkError
    }
    
    func sendEmailVerification(email: String) async throws -> Bool {
        throw PaymentError.networkError
    }
    
    func verifyEmail(token: String, email: String) async throws -> Bool {
        throw PaymentError.networkError
    }
    
    func resetPassword(email: String) async throws -> Bool {
        throw PaymentError.networkError
    }
    
    func getShows() async throws -> [Show] {
        throw PaymentError.networkError
    }
    
    func getShow(id: String) async throws -> Show {
        throw PaymentError.networkError
    }
    
    func getShowSeats(showId: String) async throws -> [Seat] {
        throw PaymentError.networkError
    }
    
    func getShowSeatmap(showId: String) async throws -> SeatMapResponse {
        throw PaymentError.networkError
    }
    
    func createSeatReservation(request: SeatReservationRequest) async throws -> ReservationResponse {
        throw PaymentError.networkError
    }
    
    func getUserBookings() async throws -> [UserBooking] {
        throw PaymentError.networkError
    }
    
    func getBookingConfirmation(sessionId: String) async throws -> BookingConfirmation {
        throw PaymentError.networkError
    }
    
    func validateVenueTicket(venueId: String, validationCode: String) async throws -> TicketValidationResponse {
        throw PaymentError.networkError
    }
    
    func getVenueShows(venueId: String) async throws -> [Show] {
        throw PaymentError.networkError
    }
    
    func getVenueBookings(venueId: String, date: String?) async throws -> [UserBooking] {
        throw PaymentError.networkError
    }
    
    func checkEnvironment() async throws -> EnvironmentResponse {
        throw PaymentError.networkError
    }
}

// MARK: - Mock OfflineDataManager

class MockOfflineDataManager: PaymentOfflineDataManagerProtocol {
    static let shared = MockOfflineDataManager()
    
    private var cachedBookings: [LocalUserBooking] = []
    
    private init() {}
    
    func getCachedUserBookings() async throws -> [LocalUserBooking]? {
        // Simulate storage access delay
        try await Task.sleep(nanoseconds: 100_000_000)
        return cachedBookings.isEmpty ? nil : cachedBookings
    }
    
    func cacheUserBookings(_ bookings: [LocalUserBooking]) async throws {
        // Simulate storage write delay
        try await Task.sleep(nanoseconds: 200_000_000)
        
        // Simulate occasional storage failures (2% chance)
        if Int.random(in: 1...50) == 1 {
            throw PaymentError.ticketStorageFailed
        }
        
        self.cachedBookings = bookings
        print("ðŸ“± OfflineDataManager: Successfully cached \(bookings.count) bookings")
    }
}

// MARK: - Payment Flow Coordinator Protocol

protocol PaymentFlowCoordinatorProtocol: ObservableObject {
    // Payment methods
    func processPayment(for booking: BookingRequest) async throws -> BookingConfirmation
    func processApplePayment(for booking: BookingRequest) async throws -> BookingConfirmation
    
    // Payment state
    var paymentState: PaymentState { get }
    var isProcessingPayment: Bool { get }
    var paymentError: PaymentError? { get }
    
    // Apple Pay availability
    func isApplePayAvailable() -> Bool
    func setupApplePay(for booking: BookingRequest) -> PKPaymentRequest?
}

// MARK: - Payment State

enum PaymentState: Equatable {
    case idle
    case loadingPaymentSheet
    case processingPayment
    case awaitingConfirmation
    case completed(LocalBookingConfirmation)
    case failed(PaymentError)
    
    static func == (lhs: PaymentState, rhs: PaymentState) -> Bool {
        switch (lhs, rhs) {
        case (.idle, .idle), (.loadingPaymentSheet, .loadingPaymentSheet),
             (.processingPayment, .processingPayment), (.awaitingConfirmation, .awaitingConfirmation):
            return true
        case (.completed(let lhsBooking), .completed(let rhsBooking)):
            return lhsBooking.bookingId == rhsBooking.bookingId
        case (.failed(let lhsError), .failed(let rhsError)):
            return lhsError.localizedDescription == rhsError.localizedDescription
        default:
            return false
        }
    }
}

// MARK: - Payment Error

enum PaymentError: LocalizedError, Equatable {
    case paymentCancelled
    case paymentFailed(String)
    case networkError
    case invalidPaymentMethod
    case applePayNotAvailable
    case stripeConfigurationError
    case bookingCreationFailed
    case ticketStorageFailed
    
    var errorDescription: String? {
        switch self {
        case .paymentCancelled:
            return "Payment was cancelled"
        case .paymentFailed(let message):
            return "Payment failed: \(message)"
        case .networkError:
            return "Network error. Please check your connection."
        case .invalidPaymentMethod:
            return "Invalid payment method"
        case .applePayNotAvailable:
            return "Apple Pay is not available on this device"
        case .stripeConfigurationError:
            return "Payment configuration error"
        case .bookingCreationFailed:
            return "Failed to create booking"
        case .ticketStorageFailed:
            return "Payment successful but failed to save ticket locally"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .paymentCancelled:
            return "Try again or use a different payment method"
        case .paymentFailed:
            return "Please check your payment details and try again"
        case .networkError:
            return "Check your internet connection and retry"
        case .invalidPaymentMethod:
            return "Please select a valid payment method"
        case .applePayNotAvailable:
            return "Use credit card payment instead"
        case .stripeConfigurationError:
            return "Please try again later"
        case .bookingCreationFailed:
            return "Please try booking again"
        case .ticketStorageFailed:
            return "Your tickets are available in your account"
        }
    }
    
    static func == (lhs: PaymentError, rhs: PaymentError) -> Bool {
        switch (lhs, rhs) {
        case (.paymentCancelled, .paymentCancelled),
             (.networkError, .networkError),
             (.invalidPaymentMethod, .invalidPaymentMethod),
             (.applePayNotAvailable, .applePayNotAvailable),
             (.stripeConfigurationError, .stripeConfigurationError),
             (.bookingCreationFailed, .bookingCreationFailed),
             (.ticketStorageFailed, .ticketStorageFailed):
            return true
        case (.paymentFailed(let lhsMessage), .paymentFailed(let rhsMessage)):
            return lhsMessage == rhsMessage
        default:
            return false
        }
    }
}

// MARK: - Payment Flow Coordinator Implementation

@MainActor
class PaymentFlowCoordinator: NSObject, PaymentFlowCoordinatorProtocol {
    
    // MARK: - Published Properties
    
    @Published private(set) var paymentState: PaymentState = .idle
    @Published private(set) var isProcessingPayment: Bool = false
    @Published private(set) var paymentError: PaymentError?
    
    // MARK: - Private Properties
    
    private var cancellables = Set<AnyCancellable>()
    private let offlineDataManager: PaymentOfflineDataManagerProtocol
    private let apiClient: APIClientProtocol
    private var currentBookingRequest: BookingRequest?
    private var currentTask: Task<Void, Never>?
    
    // Stripe Configuration
    private let stripePublishableKey = "pk_test_..." // TODO: Replace with actual key
    private var paymentIntentClientSecret: String?
    
    // Apple Pay Configuration
    private let merchantIdentifier = "merchant.com.lastminutelive.app"
    private let serviceFeeInPence = 250 // Â£2.50 service fee
    
    // MARK: - Initialization
    
    init(offlineDataManager: PaymentOfflineDataManagerProtocol = MockOfflineDataManager.shared, 
         apiClient: APIClientProtocol = PaymentMockAPIClient.shared) {
        self.offlineDataManager = offlineDataManager
        self.apiClient = apiClient
        super.init()
        setupPaymentConfiguration()
    }
    
    private func setupPaymentConfiguration() {
        // Configure Stripe - TODO: Replace with actual publishable key
        StripeAPI.defaultPublishableKey = stripePublishableKey
    }
    
    // MARK: - Payment Validation
    
    private func validateBookingRequest(_ booking: BookingRequest) throws {
        guard !booking.selectedSeats.isEmpty else {
            throw PaymentError.invalidPaymentMethod
        }
        
        guard booking.totalAmount > 0 else {
            throw PaymentError.invalidPaymentMethod
        }
        
        guard !booking.showId.isEmpty, !booking.showTitle.isEmpty else {
            throw PaymentError.bookingCreationFailed
        }
        
        // Validate seat pricing consistency
        let calculatedTotal = booking.selectedSeats.reduce(0) { $0 + $1.pricePence }
        guard abs(calculatedTotal - booking.totalAmount) <= serviceFeeInPence else {
            print("âš ï¸ Price mismatch: calculated=\(calculatedTotal), provided=\(booking.totalAmount)")
        }
    }
    
    // MARK: - Main Payment Processing
    
    func processPayment(for booking: BookingRequest) async throws -> BookingConfirmation {
        // Validate input
        try validateBookingRequest(booking)
        
        // Cancel any existing payment
        currentTask?.cancel()
        
        currentBookingRequest = booking
        updateState(.loadingPaymentSheet)
        setProcessingPayment(true)
        clearError()
        
        currentTask = Task {
            defer {
                setProcessingPayment(false)
                currentTask = nil
            }
            
            do {
                // Step 1: Create payment intent on server
                guard !Task.isCancelled else { throw CancellationError() }
                let paymentIntent = try await apiClient.createPaymentIntent(for: booking, applePayMethod: nil)
                paymentIntentClientSecret = paymentIntent.clientSecret
                
                // Step 2: Process payment with Stripe
                guard !Task.isCancelled else { throw CancellationError() }
                let paymentResult = try await processStripePayment(clientSecret: paymentIntent.clientSecret)
                
                // Step 3: Confirm booking after successful payment
                guard !Task.isCancelled else { throw CancellationError() }
                var bookingConfirmation = try await apiClient.confirmBooking(
                    paymentIntentId: paymentResult.paymentIntentId,
                    booking: booking
                )
                
                // Step 4: Generate QR code
                let qrCode = generateQRCodeData(bookingId: bookingConfirmation.bookingId)
                bookingConfirmation = BookingConfirmation(
                    bookingId: bookingConfirmation.bookingId,
                    showId: bookingConfirmation.showId,
                    showTitle: bookingConfirmation.showTitle,
                    showDate: bookingConfirmation.showDate,
                    showTime: bookingConfirmation.showTime,
                    venueName: bookingConfirmation.venueName,
                    venueAddress: bookingConfirmation.venueAddress,
                    seats: bookingConfirmation.seats,
                    totalAmount: bookingConfirmation.totalAmount,
                    paymentIntentId: bookingConfirmation.paymentIntentId,
                    qrCode: qrCode,
                    bookingDate: bookingConfirmation.bookingDate,
                    status: bookingConfirmation.status
                )
                
                // Step 5: Store ticket locally for offline access
                guard !Task.isCancelled else { throw CancellationError() }
                try await storeTicketLocally(bookingConfirmation)
                
                updateState(.completed(bookingConfirmation))
                print("ðŸ’³ PaymentFlowCoordinator: Payment completed successfully")
                
            } catch {
                await handlePaymentError(error)
                throw error
            }
        }
        
        // Wait for task completion and return result
        return try await withTaskCancellationHandler {
            currentTask?.cancel()
        } operation: {
            try await currentTask?.value
            guard case .completed(let confirmation) = paymentState else {
                throw PaymentError.paymentFailed("Payment processing failed")
            }
            return confirmation
        }
    }
    
    func processApplePayment(for booking: BookingRequest) async throws -> BookingConfirmation {
        guard isApplePayAvailable() else {
            throw PaymentError.applePayNotAvailable
        }
        
        // Validate input
        try validateBookingRequest(booking)
        
        // Cancel any existing payment
        currentTask?.cancel()
        
        currentBookingRequest = booking
        updateState(.processingPayment)
        setProcessingPayment(true)
        clearError()
        
        currentTask = Task {
            defer {
                setProcessingPayment(false)
                currentTask = nil
            }
            
            do {
                // Step 1: Create Apple Pay payment request
                guard let paymentRequest = setupApplePay(for: booking) else {
                    throw PaymentError.stripeConfigurationError
                }
                
                // Step 2: Present Apple Pay and get payment method
                guard !Task.isCancelled else { throw CancellationError() }
                let paymentMethod = try await presentApplePay(with: paymentRequest)
                
                // Step 3: Create payment intent with Apple Pay
                guard !Task.isCancelled else { throw CancellationError() }
                let paymentIntent = try await apiClient.createPaymentIntent(for: booking, applePayMethod: paymentMethod)
                
                // Step 4: Confirm payment
                guard !Task.isCancelled else { throw CancellationError() }
                let paymentResult = try await confirmApplePayPayment(
                    clientSecret: paymentIntent.clientSecret,
                    paymentMethod: paymentMethod
                )
                
                // Step 5: Confirm booking
                guard !Task.isCancelled else { throw CancellationError() }
                var bookingConfirmation = try await apiClient.confirmBooking(
                    paymentIntentId: paymentResult.paymentIntentId,
                    booking: booking
                )
                
                // Step 6: Generate QR code
                let qrCode = generateQRCodeData(bookingId: bookingConfirmation.bookingId)
                bookingConfirmation = BookingConfirmation(
                    bookingId: bookingConfirmation.bookingId,
                    showId: bookingConfirmation.showId,
                    showTitle: bookingConfirmation.showTitle,
                    showDate: bookingConfirmation.showDate,
                    showTime: bookingConfirmation.showTime,
                    venueName: bookingConfirmation.venueName,
                    venueAddress: bookingConfirmation.venueAddress,
                    seats: bookingConfirmation.seats,
                    totalAmount: bookingConfirmation.totalAmount,
                    paymentIntentId: bookingConfirmation.paymentIntentId,
                    qrCode: qrCode,
                    bookingDate: bookingConfirmation.bookingDate,
                    status: bookingConfirmation.status
                )
                
                // Step 7: Store ticket locally
                guard !Task.isCancelled else { throw CancellationError() }
                try await storeTicketLocally(bookingConfirmation)
                
                updateState(.completed(bookingConfirmation))
                print("ðŸŽ PaymentFlowCoordinator: Apple Pay payment completed successfully")
                
            } catch {
                await handlePaymentError(error)
                throw error
            }
        }
        
        // Wait for task completion and return result
        return try await withTaskCancellationHandler {
            currentTask?.cancel()
        } operation: {
            try await currentTask?.value
            guard case .completed(let confirmation) = paymentState else {
                throw PaymentError.paymentFailed("Apple Pay processing failed")
            }
            return confirmation
        }
    }
    
    // MARK: - Error Handling
    
    private func handlePaymentError(_ error: Error) async {
        let paymentError: PaymentError
        
        if error is CancellationError {
            paymentError = .paymentCancelled
        } else if let existingError = error as? PaymentError {
            paymentError = existingError
        } else {
            paymentError = .paymentFailed(error.localizedDescription)
        }
        
        updateState(.failed(paymentError))
        self.paymentError = paymentError
    }
    
    private func updateState(_ newState: PaymentState) {
        paymentState = newState
    }
    
    // MARK: - Apple Pay Support
    
    func isApplePayAvailable() -> Bool {
        return PKPaymentAuthorizationViewController.canMakePayments() &&
               PKPaymentAuthorizationViewController.canMakePayments(usingNetworks: [.visa, .masterCard, .amex])
    }
    
    func setupApplePay(for booking: BookingRequest) -> PKPaymentRequest? {
        let paymentRequest = PKPaymentRequest()
        
        paymentRequest.merchantIdentifier = merchantIdentifier
        paymentRequest.supportedNetworks = [.visa, .masterCard, .amex, .discover]
        paymentRequest.supportedCountries = ["US", "GB", "CA"]
        paymentRequest.merchantCapabilities = .capability3DS
        paymentRequest.countryCode = "GB"
        paymentRequest.currencyCode = "GBP"
        
        // Create payment summary items
        var paymentItems: [PKPaymentSummaryItem] = []
        
        // Add seat items grouped by section
        for (section, seats) in booking.seatsBySection {
            let sectionTotal = seats.count * (booking.sectionPricing[section] ?? 0)
            let pounds = Double(sectionTotal) / 100.0
            
            let item = PKPaymentSummaryItem(
                label: "\(seats.count) Ã— \(section.capitalized)",
                amount: NSDecimalNumber(value: pounds)
            )
            paymentItems.append(item)
        }
        
        // Add service fee consistently
        let serviceFee = PKPaymentSummaryItem(
            label: "Service Fee",
            amount: NSDecimalNumber(value: Double(serviceFeeInPence) / 100.0)
        )
        paymentItems.append(serviceFee)
        
        // Calculate total with service fee
        let totalWithFee = booking.totalAmount + serviceFeeInPence
        let totalPounds = Double(totalWithFee) / 100.0
        let total = PKPaymentSummaryItem(
            label: "Last Minute Live",
            amount: NSDecimalNumber(value: totalPounds)
        )
        paymentItems.append(total)
        
        paymentRequest.paymentSummaryItems = paymentItems
        
        // Contact information requirements
        paymentRequest.requiredBillingContactFields = [.emailAddress, .name]
        paymentRequest.requiredShippingContactFields = [.emailAddress]
        
        return paymentRequest
    }
    
    // MARK: - Apple Pay Delegate Methods
    
    private func presentApplePay(with paymentRequest: PKPaymentRequest) async throws -> PKPaymentMethod {
        // Create a mock payment method for testing
        // TODO: Replace with real PKPaymentAuthorizationViewController implementation
        
        // Simulate Apple Pay UI delay
        try await Task.sleep(nanoseconds: UInt64.random(in: 1_000_000_000...3_000_000_000))
        
        // Simulate user cancellation (15% chance)
        if Int.random(in: 1...7) == 1 {
            throw PaymentError.paymentCancelled
        }
        
        // Create a mock payment method that won't crash
        // In real implementation, this would be a real PKPaymentMethod from Apple Pay
        let mockPaymentMethod = MockPKPaymentMethod()
        return mockPaymentMethod.asPaymentMethod()
    }
    
    // MARK: - Payment Processing Methods
    
    private func processStripePayment(clientSecret: String) async throws -> PaymentResult {
        // TODO: Replace with real Stripe SDK payment processing
        
        updateState(.processingPayment)
        
        // Validate client secret format
        guard clientSecret.contains("pi_") && clientSecret.contains("secret") else {
            throw PaymentError.stripeConfigurationError
        }
        
        // Simulate payment processing with realistic timing
        try await Task.sleep(nanoseconds: UInt64.random(in: 2_000_000_000...5_000_000_000))
        
        // Simulate payment failures (8% chance)
        if Int.random(in: 1...13) == 1 {
            let failures = [
                "Your card was declined.",
                "Insufficient funds.",
                "Your card has expired.",
                "Your card's security code is incorrect."
            ]
            throw PaymentError.paymentFailed(failures.randomElement()!)
        }
        
        // Extract payment intent ID from client secret
        let paymentIntentId = String(clientSecret.prefix(while: { $0 != "_" }))
        
        return PaymentResult(
            paymentIntentId: paymentIntentId,
            status: "succeeded"
        )
    }
    
    private func confirmApplePayPayment(clientSecret: String, paymentMethod: PKPaymentMethod) async throws -> PaymentResult {
        // TODO: Replace with real Apple Pay confirmation via Stripe
        
        // Validate inputs
        guard clientSecret.contains("applepay") else {
            throw PaymentError.stripeConfigurationError
        }
        
        // Simulate Apple Pay processing
        try await Task.sleep(nanoseconds: UInt64.random(in: 1_500_000_000...3_000_000_000))
        
        // Simulate occasional Apple Pay failures (5% chance)
        if Int.random(in: 1...20) == 1 {
            throw PaymentError.paymentFailed("Apple Pay authorization failed")
        }
        
        let paymentIntentId = String(clientSecret.prefix(while: { $0 != "_" }))
        
        return PaymentResult(
            paymentIntentId: paymentIntentId,
            status: "succeeded"
        )
    }
    
    // MARK: - Local Ticket Storage (Local-First)
    
    private func storeTicketLocally(_ bookingConfirmation: LocalBookingConfirmation) async throws {
        do {
            // Convert to LocalUserBooking for storage
            let userBooking = LocalUserBooking(
                id: bookingConfirmation.bookingId,
                showId: bookingConfirmation.showId,
                showTitle: bookingConfirmation.showTitle,
                showDate: bookingConfirmation.showDate,
                showTime: bookingConfirmation.showTime,
                venueName: bookingConfirmation.venueName,
                venueAddress: bookingConfirmation.venueAddress,
                seats: bookingConfirmation.seats.map { seat in
                    LocalBookingSeat(
                        id: seat.id,
                        number: String(seat.seatNumber),
                        row: seat.rowLetter,
                        section: seat.sectionId,
                        priceInPence: seat.pricePence
                    )
                },
                totalAmount: bookingConfirmation.totalAmount,
                status: .confirmed,
                qrCode: bookingConfirmation.qrCode,
                bookingDate: bookingConfirmation.bookingDate
            )
            
            // Store in local cache with retry logic
            do {
                let currentBookings = try await offlineDataManager.getCachedUserBookings() ?? []
                let updatedBookings = currentBookings + [userBooking]
                try await offlineDataManager.cacheUserBookings(updatedBookings)
                
                print("ðŸŽ« PaymentFlowCoordinator: Ticket stored locally for offline access")
                
            } catch {
                print("ðŸŽ« PaymentFlowCoordinator: Failed to cache bookings: \(error)")
                // Don't fail the payment for storage issues, just warn
                print("âš ï¸ Warning: Payment succeeded but local storage failed. Ticket is available online.")
            }
            
        } catch {
            print("ðŸŽ« PaymentFlowCoordinator: Failed to prepare ticket for storage: \(error)")
            // Don't throw for local storage failures - payment was successful
        }
    }
    
    // MARK: - QR Code Generation
    
    private func generateQRCodeData(bookingId: String) -> String {
        // Generate secure QR code data that can be scanned at venue
        let timestamp = Date()
        let qrData = QRCodeData(
            bookingId: bookingId,
            timestamp: timestamp,
            checksum: generateChecksum(for: bookingId, timestamp: timestamp)
        )
        
        // Convert to JSON string
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        
        do {
            let jsonData = try encoder.encode(qrData)
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                return jsonString
            }
        } catch {
            print("âš ï¸ Failed to encode QR data: \(error)")
        }
        
        // Fallback to simple format
        return "\(bookingId)|\(timestamp.timeIntervalSince1970)"
    }
    
    private func generateChecksum(for bookingId: String, timestamp: Date) -> String {
        // Generate a more secure checksum using multiple factors
        let combinedString = "\(bookingId)|\(timestamp.timeIntervalSince1970)|\(merchantIdentifier)"
        let hash = combinedString.hash
        return String(format: "%08X", abs(hash))
    }
    
    // MARK: - Helper Methods
    
    private func setProcessingPayment(_ processing: Bool) {
        isProcessingPayment = processing
    }
    
    private func clearError() {
        paymentError = nil
    }
    
    // MARK: - Reset Methods
    
    func resetPaymentFlow() {
        currentTask?.cancel()
        updateState(.idle)
        setProcessingPayment(false)
        clearError()
        currentBookingRequest = nil
        paymentIntentClientSecret = nil
    }
    
    // MARK: - Cancellation Support
    
    func cancelPayment() {
        currentTask?.cancel()
        resetPaymentFlow()
    }
}

// MARK: - Mock PKPaymentMethod

private class MockPKPaymentMethod {
    func asPaymentMethod() -> PKPaymentMethod {
        // Create a minimal mock that won't crash
        // In real implementation, this would be a real PKPaymentMethod from Apple Pay
        let paymentMethod = PKPaymentMethod()
        return paymentMethod
    }
}

// MARK: - Supporting Models

struct BookingRequest: Codable, Equatable {
    let showId: String
    let showTitle: String
    let showDate: String
    let showTime: String
    let venueName: String
    let venueAddress: String
    let selectedSeats: [Seat]
    let sectionPricing: [String: Int]
    let totalAmount: Int
    
    var seatsBySection: [String: [Seat]] {
        Dictionary(grouping: selectedSeats) { $0.sectionId }
    }
}

struct PaymentIntentResponse: Codable, Equatable {
    let clientSecret: String
    let amount: Int
    let currency: String
}

struct PaymentResult: Codable, Equatable {
    let paymentIntentId: String
    let status: String
}

// Local models for payment flow - different from API models
struct LocalBookingConfirmation: Codable, Equatable {
    let bookingId: String
    let showId: String
    let showTitle: String
    let showDate: String
    let showTime: String
    let venueName: String
    let venueAddress: String
    let seats: [Seat]
    let totalAmount: Int
    let paymentIntentId: String
    let qrCode: String
    let bookingDate: Date
    let status: BookingStatus
}

// Local storage model for offline tickets - different from API UserBooking
struct LocalUserBooking: Codable, Equatable {
    let id: String
    let showId: String
    let showTitle: String
    let showDate: String
    let showTime: String
    let venueName: String
    let venueAddress: String
    let seats: [LocalBookingSeat]
    let totalAmount: Int
    let status: BookingStatus
    let qrCode: String
    let bookingDate: Date
}

struct LocalBookingSeat: Codable, Equatable {
    let id: String
    let number: String
    let row: String
    let section: String
    let priceInPence: Int
}

 